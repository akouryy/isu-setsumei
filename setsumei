#!/usr/bin/env ruby

require 'optparse'
require 'shellwords'
require 'tempfile'

class Config
  ALWAYS = :always
  AUTO = :auto
  NEVER = :never

  attr_writer :v_num, :v_limit, :v_offset, :v_str, :v_like

  def initialize
    self.v_num = 1
    self.v_limit = nil
    self.v_offset = nil
    self.v_str = "a%a"
    self.v_like = nil
  end

  def verbose?; $VERBOSE end

  def verbose= v; $VERBOSE = v end

  def num; @v_num end

  def limit; @v_limit || num end

  def offset; @v_offset || num end

  def str; @v_str end

  def like; @v_like || str end
end

$conf = Config.new

def warn str
  Kernel.warn "WARNING: #{str}"
end

def debug str
  $stderr.puts "DEBUG: #{str}" if $conf.verbose?
end

class Array
  def soft_transpose
    Array.new(map(&:size).max){|i| map{|e| e[i] } }
  end
end

def format_response res
  table = [res.lines[0], *res.lines.grep_v(/^id\b/)].map{ _1.chomp.split "\t" }

  sizes = table.soft_transpose.map{|col| col.compact.map(&:size).max }

  uncolored = table.map do |row|
    row.zip(sizes).map do |c, s|
      c.ljust s
    end.join(" ").rstrip
  end.join "\n"

  `printf #{Shellwords.shellescape uncolored} | grep --color=always -E "filesort|"`
end

begin
  ########## Parse command-line arguments ##########
  opt = OptionParser.new

  opt.on '-n', "--number NUM", Integer, "Set the replacement value for number placeholders" do |n|
    $conf.v_num = n
  end

  opt.on '-l', "--limit NUM", Integer, "Specify the replacement value for LIMIT placeholders" do |n|
    $conf.v_limit = n
  end

  opt.on '-o', "--offset NUM", Integer, "Specify the replacement value for OFFSET placeholders" do |n|
    $conf.v_offset = n
  end

  opt.on '-s', "--string STR", "Set the unescaped replacement value for string placeholders" do |s|
    $conf.v_str = s
  end

  opt.on '-k', "--like STR", "Specify the unescaped replacement value for LIKE placeholders" do |s|
    $conf.v_like = s
  end

  opt.on '-v', "--verbose", "Output more debug messages" do |b|
    raise OptionParser::InvalidArgument, b unless b
    $conf.verbose = true
  end

  opt.banner += " [slow_query_files]"
  opt.version = [1, 0, 0]

  opt.permute! ARGV

  ########## Generate an EXPLAIN query ##########

  debug "Reading from stdin..." if ARGV.empty?

  statements = gets(nil).split("\n\n").map do |entry|
    next if entry !~ /\S/

    header, *stmt = entry.lines(chomp: true).grep_v ""

    raise [:invalid_header, entry].inspect if header !~ /^Count/

    stmt.join.gsub(/\b LIMIT \s+ N \b/ix, "LIMIT #{$conf.limit}")
             .gsub(/\b OFFSET \s+ N \b/ix, "OFFSET #{$conf.offset}")
             .gsub(/\b N \b/ix, $conf.num.to_s)
             .gsub(/\b LIKE \s+ S \b/ix, "LIKE #{$conf.like.inspect}")
             .gsub(/\b S \b/ix, $conf.str.inspect)
  end

  raise [:empty_log, statements].inspect if statements.empty?

  # query = "EXPLAIN   (" + statements.join(")\nUNION ALL (") + ");"
  query = statements.map{ "EXPLAIN #{_1};" }.join "\n"
  debug query.delete "\n"

  query_file = Tempfile.open do |query_file|
    debug "open tempfile #{query_file} (#{query_file.path})"
    query_file.print query
    query_file.flush
  end
  
  debug "tempfile content: #{File.read(query_file.path).delete "\n"}"

  ########## Execute the query ##########
  res = begin
    host = ENV.fetch 'MYSQL_HOST', '127.0.0.1'
    port = ENV.fetch 'MYSQL_PORT', '3306'
    user = ENV.fetch 'MYSQL_USER', 'isucon'
    pass = ENV.fetch 'MYSQL_PASS', 'isucon'
    dbname = ENV.fetch 'MYSQL_DBNAME', 'isuumo'

    debug "cat #{query_file.path} | mysql -h#{host} -P#{port} -u#{user} -p#{pass} #{dbname}"
    res = `cat #{query_file.path} | mysql -h#{host} -P#{port} -u#{user} -p#{pass} #{dbname}`
    debug $?.inspect
    res
  end

  puts format_response res

rescue => err
  $stderr.puts err.full_message
  puts

  puts opt.help
  exit 10
end
