#!/usr/bin/env ruby

require 'optparse'
require 'shellwords'
require 'tempfile'

class Config
  ALWAYS = :always
  AUTO = :auto
  NEVER = :never
  COLORS = [ALWAYS, AUTO, NEVER].freeze

  attr_writer :v_num, :v_limit, :v_offset, :v_str, :v_like, :output_queries

  def initialize
    self.v_num = 1
    self.v_limit = nil
    self.v_offset = nil
    self.v_str = "a%a"
    self.v_like = nil
    self.output_queries = false
    self.color = AUTO
    @specials = {}
  end

  def verbose?; $VERBOSE end

  def verbose= v; $VERBOSE = v end

  def num; @v_num end

  def limit; @v_limit || num end

  def offset; @v_offset || num end

  def str; @v_str end

  def like; @v_like || str end

  def output_queries?; @output_queries end

  def color?
    @color == ALWAYS || @color == AUTO && $stdout.tty?
  end

  def color= v
    raise v.to_s unless COLORS.include? v
    @color = v
  end

  def special r, c
    debug @specials if r == 0 && c == 0
    @specials[[r, c]]
  end

  def add_special r, c, v
    @specials[[r, c]] = v
  end
end

$conf = Config.new

def warn str
  Kernel.warn "WARNING: #{str}"
end

def debug str
  $stderr.puts "DEBUG: #{str}" if $conf.verbose?
end

def fill_placeholders stmt, row
  col = 0
  stmt.gsub %r[
    \b
    (?<prefix_sp>
      (?i:
        (?<prefix> LIMIT | OFFSET | LIKE )
        \s+
      )?
    )
    (?<ph> [NS])
    \b
  ]x do
    debug "special(#{row}, #{col}) => #{$conf.special(row, col).inspect}"

    fill =
      $conf.special(row, col) ||
        case $~[:prefix]
        when 'LIMIT' then $conf.limit.to_s
        when 'OFFSET' then $conf.offset.to_s
        when 'LIKE' then $conf.like.inspect
        when nil
          case $~[:ph]
          when 'N' then $conf.num.to_s
          when 'S' then $conf.str.inspect
          end
        end

    col += 1

    $~[:prefix_sp] + fill
  end
end

class Array
  def soft_transpose
    Array.new(map(&:size).max){|i| map{|e| e[i] } }
  end
end

def format_response res
  table = [res.lines[0], *res.lines.grep_v(/^id\b/)].map{ _1.chomp.split "\t" }

  sizes = table.soft_transpose.map{|col| col.compact.map(&:size).max }

  uncolored = table.map do |row|
    row.zip(sizes).map do |c, s|
      c.ljust s
    end.join(" ").rstrip
  end.join "\n"

  if $conf.color?
    `printf #{Shellwords.shellescape uncolored} | grep --color=always -E "filesort|"`
  else
    uncolored
  end
end

begin
  ########## Parse command-line arguments ##########
  opt = OptionParser.new

  opt.on '-n', "--number NUM", Integer, "Set the replacement value for number placeholders" do |n|
    $conf.v_num = n
  end

  opt.on '-l', "--limit NUM", Integer, "Specify the replacement value for LIMIT placeholders" do |n|
    $conf.v_limit = n
  end

  opt.on '-o', "--offset NUM", Integer, "Specify the replacement value for OFFSET placeholders" do |n|
    $conf.v_offset = n
  end

  opt.on '-s', "--string STR", "Set the unescaped replacement value for string placeholders" do |s|
    $conf.v_str = s
  end

  opt.on '-k', "--like STR", "Specify the unescaped replacement value for LIKE placeholders" do |s|
    $conf.v_like = s
  end

  opt.on '-c', "--color WHEN", Config::COLORS,
         "Specify when to highlight words; " +
         "WHEN can be `auto` (default), `always`, or `never`" do |s|
    $conf.color = s
  end

  opt.on '-q', "--query", "Output EXPLAIN queries" do |b|
    raise OptionParser::InvalidArgument, b unless b
    $conf.output_queries = true
  end

  SPECIAL_REGEX = /\A \s* (\d+) \s* , \s* (\d+) \s* , (.+) \z/x

  opt.on '-a', "--add-special ROW,COL,VAL", SPECIAL_REGEX,
         "Specify the special replacement value for one placeholder" do |_, r, c, v|

    $conf.add_special r.to_i, c.to_i, v
  end

  opt.on '-v', "--verbose", "Output more debug messages" do |b|
    raise OptionParser::InvalidArgument, b unless b
    $conf.verbose = true
  end

  opt.banner += " [slow_query_files]"
  opt.version = [1, 0, 0]

  opt.permute! ARGV

  ########## Generate EXPLAIN queries ##########

  debug "Reading from stdin..." if ARGV.empty?

  statements = gets(nil).split("\n\n").map.with_index do |entry, row|
    next if entry !~ /\S/

    header, *stmt = entry.lines(chomp: true).grep_v ""

    raise [:invalid_header, entry].inspect if header !~ /^Count/

    fill_placeholders stmt.join, row
  end

  raise [:empty_log, statements].inspect if statements.empty?

  query = statements.map{ "EXPLAIN #{_1};" }.join "\n"

  if $conf.output_queries?
    puts query.lines.map.with_index{ "[#{_2}] #{_1}" }
    puts
  else
    debug query.delete "\n"
  end

  query_file = Tempfile.open do |query_file|
    debug "open tempfile #{query_file} (#{query_file.path})"
    query_file.print query
    query_file.flush
  end

  debug "tempfile content: #{File.read(query_file.path).delete "\n"}"

  ########## Execute the queries ##########
  res = begin
    host = ENV.fetch 'MYSQL_HOST', '127.0.0.1'
    port = ENV.fetch 'MYSQL_PORT', '3306'
    user = ENV.fetch 'MYSQL_USER', 'isucon'
    pass = ENV.fetch 'MYSQL_PASS', 'isucon'
    dbname = ENV.fetch 'MYSQL_DBNAME', 'isuumo'

    debug "cat #{query_file.path} | mysql -h#{host} -P#{port} -u#{user} -p#{pass} #{dbname}"
    res = `cat #{query_file.path} | mysql -h#{host} -P#{port} -u#{user} -p#{pass} #{dbname}`
    debug $?.inspect
    res
  end

  puts format_response res

rescue => err
  $stderr.puts err.full_message
  puts

  puts opt.help
  exit 10
end
